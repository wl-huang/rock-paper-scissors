<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å¼·åŒ–ç‰ˆ çŸ³é ­å‰ªåˆ€å¸ƒ AI</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; margin-top: 50px; background-color: #f5f5f5; }
    h1 { color: #333; }
    button { margin: 5px; padding: 10px 20px; font-size: 16px; }
    #result { font-size: 20px; margin-top: 20px; }
    #aiInfo { color: #666; margin-top: 10px; font-size: 14px; }
    #scoreboard { margin-top: 20px; }
  </style>
</head>
<body>
  <h1>çŸ³é ­å‰ªåˆ€å¸ƒ AI</h1>
  <div>
    <button onclick="playRound('å‰ªåˆ€')">âœŒï¸ å‰ªåˆ€</button>
    <button onclick="playRound('çŸ³é ­')">âœŠ çŸ³é ­</button>
    <button onclick="playRound('å¸ƒ')">ğŸ– å¸ƒ</button>
  </div>
  <div id="result"></div>
  <div id="aiInfo"></div>
  <div id="scoreboard">ç©å®¶ 0 : 0 AI</div>

  <script>
    const moves = ['å‰ªåˆ€', 'çŸ³é ­', 'å¸ƒ'];
    const counter = { 'å‰ªåˆ€': 'çŸ³é ­', 'çŸ³é ­': 'å¸ƒ', 'å¸ƒ': 'å‰ªåˆ€' };

    // æ¨¡å‹è³‡æ–™
    let playerHistory = [];
    let trans1 = { 'å‰ªåˆ€': {}, 'çŸ³é ­': {}, 'å¸ƒ': {} };
    let trans2 = {};
    let maxHist = 100;

    // é˜²å‰‹åƒæ•¸
    let decayFactor = 0.98;
    let repeatThreshold = 3;
    let exploitLoseThreshold = 3;
    let exploitEpsilon = 0.3;
    let exploitEpsilonRounds = 5;

    let exploitCooldown = 0;
    let aiConsecutiveLoses = 0;
    let epsilon = 0.05;

    // åˆ†æ•¸
    let playerScore = 0;
    let aiScore = 0;

    function randomMove() {
      return moves[Math.floor(Math.random() * moves.length)];
    }

    function makePairKey(a, b) {
      return a + '_' + b;
    }

    function updateCountsWithDecay(prev2, prev1, cur) {
      // ä¸€éšè¡°æ¸›
      for (let a of moves) {
        for (let b of moves) {
          trans1[a][b] = (trans1[a][b] || 0) * decayFactor;
        }
      }
      // äºŒéšè¡°æ¸›
      for (let k in trans2) {
        for (let m of moves) {
          trans2[k][m] = (trans2[k][m] || 0) * decayFactor;
        }
      }
      // åŠ å…¥æ–°è§€å¯Ÿ
      if (prev1) trans1[prev1][cur] = (trans1[prev1][cur] || 0) + 1;
      if (prev2 && prev1) {
        const key = makePairKey(prev2, prev1);
        if (!trans2[key]) trans2[key] = { 'å‰ªåˆ€': 0, 'çŸ³é ­': 0, 'å¸ƒ': 0 };
        trans2[key][cur] = (trans2[key][cur] || 0) + 1;
      }
    }

    function detectRepeat() {
      const n = playerHistory.length;
      if (n >= repeatThreshold) {
        const last = playerHistory[n - 1];
        for (let i = 1; i < repeatThreshold; i++) {
          if (playerHistory[n - 1 - i] !== last) return null;
        }
        return last;
      }
      return null;
    }

    function getBlendedProbs(prev2, prev1, weight2 = 5) {
      let probs1 = { 'å‰ªåˆ€': 1, 'çŸ³é ­': 1, 'å¸ƒ': 1 };
      let probs2 = { 'å‰ªåˆ€': 1, 'çŸ³é ­': 1, 'å¸ƒ': 1 };

      if (prev1 && trans1[prev1]) {
        const t1 = trans1[prev1];
        for (let m of moves) probs1[m] += t1[m] || 0;
      }

      if (prev2 && prev1) {
        const key = makePairKey(prev2, prev1);
        if (trans2[key]) {
          const t2 = trans2[key];
          for (let m of moves) probs2[m] += t2[m] || 0;
        }
      }

      const sum1 = moves.reduce((s, m) => s + probs1[m], 0);
      const sum2 = moves.reduce((s, m) => s + probs2[m], 0);
      for (let m of moves) {
        probs1[m] /= sum1;
        probs2[m] /= sum2;
      }

      const probs = {};
      for (let m of moves) {
        probs[m] = (probs1[m] + weight2 * probs2[m]) / (1 + weight2);
      }
      return probs;
    }

    function aiChoose() {
      const n = playerHistory.length;
      let currentEpsilon = epsilon;
      if (exploitCooldown > 0) {
        currentEpsilon = Math.max(currentEpsilon, exploitEpsilon);
        exploitCooldown--;
      }

      // åµæ¸¬é‡è¤‡
      const repeatMove = detectRepeat();
      if (repeatMove) {
        return { move: counter[repeatMove], probs: null, mode: 'anti-repeat' };
      }

      if (n < 1 || Math.random() < currentEpsilon) {
        return { move: randomMove(), probs: null, mode: 'random' };
      }

      const prev1 = playerHistory[n - 1];
      const prev2 = n >= 2 ? playerHistory[n - 2] : null;
      const blend = getBlendedProbs(prev2, prev1, 5);

      // æ‰¾æœ€å¤§æ©Ÿç‡
      let maxMove = moves[0];
      for (let m of moves) {
        if (blend[m] > blend[maxMove]) maxMove = m;
      }

      return { move: counter[maxMove], probs: blend, mode: 'predictive' };
    }

    function playRound(playerMove) {
      const n = playerHistory.length;
      const prev1 = n >= 1 ? playerHistory[n - 1] : null;
      const prev2 = n >= 2 ? playerHistory[n - 2] : null;

      const ai = aiChoose();
      const aiMove = ai.move;

      // åˆ¤å®šè¼¸è´
      let outcome = '';
      if (playerMove === aiMove) outcome = 'å¹³æ‰‹';
      else if (counter[playerMove] === aiMove) outcome = 'AI å‹';
      else outcome = 'ç©å®¶å‹';

      if (outcome === 'AI å‹') {
        aiScore++;
        aiConsecutiveLoses = 0;
      } else if (outcome === 'ç©å®¶å‹') {
        playerScore++;
        aiConsecutiveLoses++;
      } else aiConsecutiveLoses = 0;

      if (aiConsecutiveLoses >= exploitLoseThreshold) {
        exploitCooldown = exploitEpsilonRounds;
        aiConsecutiveLoses = 0;
      }

      updateCountsWithDecay(prev2, prev1, playerMove);
      playerHistory.push(playerMove);
      if (playerHistory.length > maxHist) playerHistory.shift();

      document.getElementById('result').innerText = `ä½ å‡º ${playerMove}ï¼ŒAI å‡º ${aiMove} â†’ ${outcome}`;
      document.getElementById('scoreboard').innerText = `ç©å®¶ ${playerScore} : ${aiScore} AI`;

      if (ai.probs) {
        const pText = moves.map(m => `${m}:${(ai.probs[m]*100).toFixed(1)}%`).join(' | ');
        document.getElementById('aiInfo').innerText = `AI æ¨¡å¼: ${ai.mode}ï¼Œé æ¸¬æ©Ÿç‡: ${pText}`;
      } else {
        document.getElementById('aiInfo').innerText = `AI æ¨¡å¼: ${ai.mode}`;
      }
    }
  </script>
</body>
</html>

