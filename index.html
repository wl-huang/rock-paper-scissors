<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>çŒœæ‹³</title>
  <style>
    body { font-family: system-ui, "å¾®è»Ÿæ­£é»‘é«”"; padding:1.2rem; background:#f6f8fa; color:#222; }
    .container { max-width:920px; margin:0 auto; background:#fff; padding:1.2rem; border-radius:10px; box-shadow:0 6px 18px rgba(30,30,30,0.06); }
    .hidden { display:none; }
    .choices { display:flex; gap:0.6rem; margin:1rem 0; }
    .choice-btn { flex:1; padding:0.75rem; border-radius:8px; border:1px solid #ddd; background:linear-gradient(#fff,#f2f4f7); cursor:pointer; font-size:1.05rem; font-weight:600; }
    .result { margin-top:1rem; padding:0.75rem; border-radius:8px; border:1px dashed #e4e7eb; background:#fcfdff; }
    .small { font-size:0.85rem; color:#666; }
    .settings label { font-size:0.9rem; color:#333; display:block; margin-top:0.4rem; }
    input[type="number"], select { margin-left:0.4rem; }
    button { cursor:pointer; padding:0.6rem 1rem; border-radius:6px; border:1px solid #ccc; background:#f9f9f9; font-size:1rem; }
    .scoreboard { display:flex; gap:0.8rem; margin-top:1rem; }
    .score-box { flex:1; padding:0.6rem; border-radius:8px; background:#f8fafc; border:1px solid #eef2f7; text-align:center; }
    .log { margin-top:1rem; max-height:220px; overflow:auto; padding:0.6rem; background:#fafafa; border-radius:8px; border:1px solid #eee; font-size:0.95rem; white-space:pre-wrap; }
    .note { margin-top:0.6rem; font-size:0.9rem; color:#444; }
  </style>
</head>
<body>
  <div class="container">
    <h1>çŒœæ‹³éŠæˆ²2.0</h1>

    <div id="setup">
      <p class="small">è«‹å…ˆè¨­å®šåƒæ•¸ï¼Œå†é–‹å§‹éŠæˆ²ã€‚</p>
      <div class="settings">
        <label>å¹³æ»‘ Î±ï¼š<input id="alpha" type="number" step="0.1" min="0" value="0.05"></label>
        <label>æ¢ç´¢ç‡ Îµï¼š<input id="epsilon" type="number" step="0.01" min="0" max="1" value="0.12"></label>
        <label>è¨˜æ†¶ä¸Šé™ï¼ˆmaxHistï¼‰ï¼š<input id="maxHist" type="number" min="10" value="200"></label>
        <label>å›æ‡‰æ¨¡å¼ï¼š
          <select id="responseMode">
            <option value="mixed">æ··åˆå›æ‡‰ï¼ˆæŒ‰æ¢ä»¶æ©Ÿç‡æ··åˆé¸æ“‡ï¼‰</option>
            <option value="max">å°æœ€å¤§è€…ç¡¬æ€§ååˆ¶ï¼ˆargmaxï¼‰</option>
          </select>
        </label>
        <button id="startBtn">é–‹å§‹éŠæˆ²</button>
      </div>
    </div>

    <div id="game" class="hidden">
      <div class="choices">
        <button class="choice-btn" data-move="scissors">âœŒï¸ å‰ªåˆ€</button>
        <button class="choice-btn" data-move="rock">ğŸª¨ çŸ³é ­</button>
        <button class="choice-btn" data-move="paper">ğŸ§» å¸ƒ</button>
      </div>

      <div class="result">
        <div id="roundInfo">å°šæœªé–‹å§‹</div>
        <div id="who" style="font-weight:700; margin-top:0.4rem;"></div>
        <div id="aiInfo" style="margin-top:0.5rem; font-size:0.95rem; color:#333;"></div>
      </div>

      <div class="note">èªªæ˜ï¼šé€™æ˜¯å€‹çŒœæ‹³éŠæˆ²ï¼ŒåŠ æ²¹ã€‚</div>

      <div class="scoreboard">
        <div class="score-box"><div class="small">ä½ </div><div id="playerScore" style="font-size:1.3rem; font-weight:700;">0</div></div>
        <div class="score-box"><div class="small">å¹³æ‰‹</div><div id="drawScore" style="font-size:1.3rem; font-weight:700;">0</div></div>
        <div class="score-box"><div class="small">é›»è…¦</div><div id="computerScore" style="font-size:1.3rem; font-weight:700;">0</div></div>
      </div>

      <button id="resetBtn" style="margin-top:0.8rem;">é‡è¨­æ¯”åˆ†èˆ‡ AI ç´€éŒ„</button>
      <div class="log" id="log"><div class="small">éŠæˆ²ç´€éŒ„ï¼ˆæœ€è¿‘è¨˜éŒ„ï¼‰</div></div>
    </div>
  </div>

  <script>
    // åŸºæœ¬è¨­å®š
    const moves = ['scissors','rock','paper'];
    const labels = { 'scissors': 'å‰ªåˆ€ âœŒï¸', 'rock': 'çŸ³é ­ ğŸª¨', 'paper': 'å¸ƒ ğŸ§»' };
    const counter = { 'scissors':'rock', 'rock':'paper', 'paper':'scissors' };

    // DOM
    const startBtn = document.getElementById('startBtn');
    const setup = document.getElementById('setup');
    const game = document.getElementById('game');
    const roundInfoEl = document.getElementById('roundInfo');
    const whoEl = document.getElementById('who');
    const aiInfoEl = document.getElementById('aiInfo');
    const logEl = document.getElementById('log');
    const playerScoreEl = document.getElementById('playerScore');
    const computerScoreEl = document.getElementById('computerScore');
    const drawScoreEl = document.getElementById('drawScore');
    const resetBtn = document.getElementById('resetBtn');

    // åƒæ•¸ & ç‹€æ…‹
    let alpha = 1.0, epsilon = 0.12, maxHist = 200, responseMode = 'mixed';
    let playerScore = 0, computerScore = 0, drawScore = 0;
    let playerHistory = []; // ä¿å­˜ç©å®¶æ­·å²ï¼ˆæœ€å¤š maxHistï¼‰
    // ä¸€éšè¨ˆæ•¸ï¼š prev -> next
    let trans1 = {
      'scissors':{'scissors':0,'rock':0,'paper':0},
      'rock':{'scissors':0,'rock':0,'paper':0},
      'paper':{'scissors':0,'rock':0,'paper':0}
    };
    // äºŒéšè¨ˆæ•¸ï¼š "prev2|prev1" -> {next:count}
    let trans2 = {}; // ä¾‹å¦‚ trans2["scissors|rock"] = {scissors:0,rock:0,paper:0}
    let historyLog = [];

    function makePairKey(a,b){ return a + '|' + b; }

    function resetAll(){
      playerScore = computerScore = drawScore = 0;
      playerHistory = [];
      historyLog = [];
      playerScoreEl.textContent = '0';
      computerScoreEl.textContent = '0';
      drawScoreEl.textContent = '0';
      // reset trans1
      for (let p of moves) for (let q of moves) trans1[p][q] = 0;
      // reset trans2
      trans2 = {};
      roundInfoEl.textContent = 'å·²é‡è¨­';
      whoEl.textContent = '';
      aiInfoEl.textContent = '';
      renderLog();
    }

    startBtn.addEventListener('click', ()=>{
      alpha = parseFloat(document.getElementById('alpha').value);
      epsilon = parseFloat(document.getElementById('epsilon').value);
      maxHist = parseInt(document.getElementById('maxHist').value, 10);
      responseMode = document.getElementById('responseMode').value;
      if (isNaN(alpha) || alpha < 0) { alert('è«‹è¼¸å…¥åˆæ³•çš„ Î±ï¼ˆ>=0ï¼‰'); return; }
      if (isNaN(epsilon) || epsilon < 0 || epsilon > 1) { alert('è«‹è¼¸å…¥åˆæ³•çš„ Îµï¼ˆ0~1ï¼‰'); return; }
      if (isNaN(maxHist) || maxHist < 10) { alert('è«‹è¼¸å…¥åˆæ³•çš„è¨˜æ†¶ä¸Šé™ï¼ˆ>=10ï¼‰'); return; }
      resetAll();
      setup.classList.add('hidden');
      game.classList.remove('hidden');
    });

    // éš¨æ©Ÿ
    function randomMove(){ return moves[Math.floor(Math.random()*moves.length)]; }

    // è¨ˆç®—ä¸€éšæ¢ä»¶æ©Ÿç‡ P(next | prev)ï¼ˆåŠ  alpha å¹³æ»‘ï¼‰
    function getFirstOrderProbs(prev){
      const counts = trans1[prev];
      let probs = {}, sum = 0;
      for (let m of moves){ probs[m] = (counts[m] || 0) + alpha; sum += probs[m]; }
      for (let m of moves) probs[m] /= sum;
      return probs;
    }

    // è¨ˆç®—äºŒéšæ¢ä»¶æ©Ÿç‡ P(next | prev2, prev1)ï¼ˆåŠ  alpha å¹³æ»‘ï¼‰
    function getSecondOrderProbs(prev2, prev1){
      const key = makePairKey(prev2, prev1);
      const counts = trans2[key] || {scissors:0,rock:0,paper:0};
      let probs = {}, sum = 0;
      for (let m of moves){ probs[m] = (counts[m] || 0) + alpha; sum += probs[m]; }
      for (let m of moves) probs[m] /= sum;
      return probs;
    }

    // AI æ±ºç­–ï¼šå„ªå…ˆç”¨äºŒéšï¼›è‹¥äºŒéšçµ„åˆæœªå‡ºç¾æˆ– prev ä¸è¶³å‰‡é€€å›ä¸€éšï¼›è‹¥ä¸€éšäº¦ä¸è¶³å‰‡éš¨æ©Ÿ
    function aiChoose(){
      const n = playerHistory.length;
      // æ¢ç´¢
      if (n < 2 || Math.random() < epsilon){
        return { move: randomMove(), mode: 'random' };
      }

      const prev1 = playerHistory[n-1];   // t-1
      const prev2 = playerHistory[n-2];   // t-2
      const pairKey = makePairKey(prev2, prev1);

      // å¦‚æœè©²äºŒéšçµ„åˆå­˜åœ¨ï¼ˆè‡³å°‘æ›¾å‡ºç¾ä¸€æ¬¡ï¼‰ï¼Œä½¿ç”¨äºŒéšæ©Ÿç‡ï¼›å¦å‰‡é€€å›ä¸€éš
      const pairExists = trans2[pairKey] && ( (trans2[pairKey].scissors||0) + (trans2[pairKey].rock||0) + (trans2[pairKey].paper||0) > 0 );
      let probs, usedOrder;
      if (pairExists){
        probs = getSecondOrderProbs(prev2, prev1);
        usedOrder = 2;
      } else {
        // è‹¥ prev1 å­˜åœ¨ä¸€éšè³‡æ–™å‰‡ä½¿ç”¨ä¸€éšï¼ˆå¹³æ»‘æœƒè™•ç† 0 æ¬¡æƒ…æ³ï¼‰
        probs = getFirstOrderProbs(prev1);
        usedOrder = 1;
      }

      // æ±ºç­–æ¨¡å¼
      if (responseMode === 'max'){
        let maxP = -1, cands = [];
        for (let m of moves){
          if (probs[m] > maxP + 1e-12) { maxP = probs[m]; cands = [m]; }
          else if (Math.abs(probs[m] - maxP) < 1e-12) cands.push(m);
        }
        const predicted = cands[Math.floor(Math.random() * cands.length)];
        return { move: counter[predicted], mode: 'max', probs: probs, predicted: predicted, order: usedOrder };
      } else {
        // mixedï¼šæŠŠç©å®¶æ¯å€‹å¯èƒ½å‡ºçš„æ©Ÿç‡è½‰æˆ AI å‡ºæ‹³æ¬Šé‡ï¼ˆååˆ¶æ¯å€‹ç©å®¶æ‰‹ï¼‰
        const aiWeights = { scissors:0, rock:0, paper:0 };
        for (let pm of moves){
          aiWeights[counter[pm]] += probs[pm];
        }
        // æ¨£æœ¬åŒ–
        const r = Math.random(); let cum = 0;
        for (let m of moves){ cum += aiWeights[m]; if (r <= cum + 1e-12) return { move: m, mode: 'mixed', probs: probs, aiWeights: aiWeights, order: usedOrder }; }
        return { move: randomMove(), mode: 'mixed', probs: probs, aiWeights: aiWeights, order: usedOrder };
      }
    }

    // æ›´æ–°è½‰ç§»è¡¨ï¼šä¸€éšèˆ‡äºŒéšéƒ½è¦æ›´æ–°
    function updateCounts(prev2, prev1, cur){
      // update first-order: prev1 -> cur
      if (prev1){
        trans1[prev1][cur] = (trans1[prev1][cur] || 0) + 1;
      }
      // update second-order: prev2|prev1 -> cur
      if (prev2 && prev1){
        const key = makePairKey(prev2, prev1);
        if (!trans2[key]) trans2[key] = {scissors:0,rock:0,paper:0};
        trans2[key][cur] = (trans2[key][cur] || 0) + 1;
      }
    }

    function decideOutcome(player, comp){
      if (player === comp) return 'draw';
      const winPairs = {'scissors':'paper','rock':'scissors','paper':'rock'};
      return winPairs[player] === comp ? 'win' : 'lose';
    }

    function playRound(playerMove){
      const aiDec = aiChoose();
      const compMove = aiDec.move;

      // å–å¾—éå»å…©æ‰‹ä»¥æ›´æ–° countsï¼ˆupdate åœ¨ç”¢ç”Ÿ aiDec ä¹‹å¾Œï¼‰
      const n = playerHistory.length;
      const prev1 = n >= 1 ? playerHistory[n-1] : null;
      const prev2 = n >= 2 ? playerHistory[n-2] : null;

      // æ›´æ–° countsï¼Œä¸¦æ”¾å…¥ playerHistoryï¼ˆç¶­æŒä¸Šé™ï¼‰
      updateCounts(prev2, prev1, playerMove);
      playerHistory.push(playerMove);
      if (playerHistory.length > maxHist) playerHistory.shift();

      // æ±ºå®šå‹è² ä¸¦æ›´æ–°åˆ†æ•¸
      const outcome = decideOutcome(playerMove, compMove);
      if (outcome === 'win') playerScore++;
      else if (outcome === 'lose') computerScore++;
      else drawScore++;
      playerScoreEl.textContent = playerScore;
      computerScoreEl.textContent = computerScore;
      drawScoreEl.textContent = drawScore;

      // é¡¯ç¤ºçµæœèˆ‡ AI è§£é‡‹ï¼ˆæ¨™è¨»æ˜¯å¦ä½¿ç”¨äºŒéšï¼‰
      roundInfoEl.textContent = 'ä½ å‡º ' + labels[playerMove] + 'ï¼Œé›»è…¦å‡º ' + labels[compMove] + 'ã€‚';
      whoEl.textContent = (outcome === 'win') ? 'ä½ è´äº†' : (outcome === 'lose') ? 'ä½ è¼¸äº†' : 'å¹³æ‰‹';
      whoEl.style.color = (outcome === 'win') ? '#0b8457' : (outcome === 'lose') ? '#c62828' : '#444';

      if (aiDec.mode === 'random'){
        aiInfoEl.textContent = 'AI ä½¿ç”¨éš¨æ©Ÿç­–ç•¥ã€‚';
      } else if (aiDec.mode === 'max'){
        const p = aiDec.probs;
        aiInfoEl.textContent = `ç©å®¶æ©Ÿç‡ï¼šå‰ªåˆ€ ${(p.scissors*100).toFixed(1)}%ã€çŸ³é ­ ${(p.rock*100).toFixed(1)}%ã€å¸ƒ ${(p.paper*100).toFixed(1)}%ã€‚AI å°æœ€å¤§è€…ç¡¬æ€§ååˆ¶ ${labels[compMove]}.`;
      } else {
        const p = aiDec.probs, w = aiDec.aiWeights;
        aiInfoEl.textContent = `ç©å®¶æ¢ä»¶æ©Ÿç‡ï¼šå‰ªåˆ€ ${(p.scissors*100).toFixed(1)}%ã€çŸ³é ­ ${(p.rock*100).toFixed(1)}%ã€å¸ƒ ${(p.paper*100).toFixed(1)}%ï¼›AI å‡ºæ‹³æ¬Šé‡ï¼šå‰ªåˆ€ ${(w.scissors*100).toFixed(1)}%ã€çŸ³é ­ ${(w.rock*100).toFixed(1)}%ã€å¸ƒ ${(w.paper*100).toFixed(1)}%ã€‚`;
      }

      // ç´€éŒ„
      const t = new Date().toLocaleTimeString();
      historyLog.unshift(t + ' â€” ä½ ï¼š' + labels[playerMove] + 'ï¼Œé›»è…¦ï¼š' + labels[compMove] + ' â†’ ' + (outcome === 'win' ? 'ä½ è´' : outcome === 'lose' ? 'ä½ è¼¸' : 'å¹³æ‰‹'));
      if (historyLog.length > 300) historyLog.pop();
      renderLog();
    }

    function renderLog(){
      logEl.innerHTML = '<div class="small">éŠæˆ²ç´€éŒ„ï¼ˆæœ€è¿‘è¨˜éŒ„ï¼‰</div>';
      for (let i=0;i<historyLog.length;i++){
        const d = document.createElement('div');
        d.textContent = historyLog[i];
        logEl.appendChild(d);
      }
    }

    // ç¶å®šæŒ‰éˆ•
    document.querySelectorAll('.choice-btn').forEach(function(btn){
      btn.addEventListener('click', function(){
        playRound(btn.getAttribute('data-move'));
      });
    });

    resetBtn.addEventListener('click', function(){
      if (!confirm('ç¢ºå®šè¦é‡è¨­æ¯”åˆ†èˆ‡ AI ç´€éŒ„å—ï¼Ÿ')) return;
      resetAll();
    });

    // é¦–æ¬¡è¼‰å…¥æ™‚é¡¯ç¤º setup å€
    resetAll();
  </script>
</body>
</html>

